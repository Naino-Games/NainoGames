<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Naino Bubble</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Rye&family=Roboto:wght@500;900&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* Default Theme: Carnival */
            --bg-color: #2E004F;
            --bg-pattern: #580096;
            --accent: #FFD700;
            --accent-dark: #DAA520;
            --text-color: #fff;
            --ui-glass: rgba(46, 0, 79, 0.95);
        }

        html, body {
            margin: 0; padding: 0;
            background: #000;
            height: 100%; width: 100%;
            overflow: hidden;
            font-family: 'Rye', serif;
            touch-action: none;
            user-select: none;
        }

        #stage {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            /* Dynamic Background Pattern */
            background: repeating-linear-gradient(
                45deg,
                var(--bg-color),
                var(--bg-color) 40px,
                var(--bg-pattern) 40px,
                var(--bg-pattern) 80px
            );
            transition: background 0.5s;
        }

        canvas {
            display: block;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border-left: 5px solid var(--accent);
            border-right: 5px solid var(--accent);
            background: rgba(0,0,0,0.3);
            max-width: 100%; max-height: 100%;
            aspect-ratio: 9/16;
            width: auto; height: 100%;
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; 
            flex-direction: column;
            /* Center menus in the middle of the stage */
            justify-content: center; 
            align-items: center; 
            z-index: 10;
            transition: opacity 0.2s;
            padding: 0;
        }
        .hidden { opacity: 0; pointer-events: none !important; }
        .interactive { pointer-events: auto; }

        /* HUD specific layout for top/bottom bars */
        #hud { 
            justify-content: space-between; 
            align-items: stretch; 
            padding: 20px; 
            box-sizing: border-box; 
        }
        
        .top-bar {
            width: 100%;
            display: flex; 
            justify-content: space-between; 
            align-items: flex-start;
        }
        
        .bottom-bar {
            width: 100%;
            display: flex;
            justify-content: space-between; 
            align-items: flex-end; 
            padding: 0 5px; 
        }

        /* Score/Level Boxes */
        .score-box { text-align: left; line-height: 1.2; }
        .score-label { color: var(--accent); font-family: 'Roboto', sans-serif; font-size: 12px; }
        .score-val { font-size: 36px; color: var(--text-color); -webkit-text-stroke: 1px var(--accent); line-height: 1; }

        .drop-counter { display: flex; gap: 5px; }
        .drop-dot { width: 10px; height: 10px; border-radius: 50%; background: #333; border: 1px solid var(--accent); }
        .drop-dot.active { background: #FF4444; box-shadow: 0 0 8px #FF4444; }
        #miss-indicator { text-align: right; line-height: 1.2; }
        
        /* Buttons */
        .btn-icon {
            width: 44px; height: 44px; border-radius: 50%;
            background: var(--accent); border: 2px solid #fff;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; box-shadow: 0 4px 0 var(--accent-dark);
            color: var(--bg-color);
            fill: var(--bg-color);
            pointer-events: auto; 
        }
        .btn-icon:active { transform: translateY(4px); box-shadow: none; }
        
        /* Menus */
        .card {
            background: var(--ui-glass);
            border: 4px solid var(--accent);
            padding: 30px; border-radius: 20px;
            text-align: center; width: 85%; max-width: 400px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            position: relative;
        }
        
        h1 {
            font-size: 48px; margin: 0 0 10px 0;
            color: var(--accent);
            text-shadow: 3px 3px 0 var(--bg-color), -1px -1px 0 #fff;
            line-height: 0.9;
        }
        
        .btn-main {
            background: linear-gradient(to bottom, var(--accent), var(--accent-dark));
            border: 2px solid #fff;
            width: 100%; padding: 15px; border-radius: 10px;
            color: var(--bg-color); font-family: 'Rye', serif;
            font-size: 20px; cursor: pointer; margin-bottom: 15px;
            box-shadow: 0 5px 0 rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        .btn-main:active { transform: translateY(5px); box-shadow: none; }
        
        .btn-row { display: flex; gap: 15px; justify-content: center; margin-top: 20px; }
        
        /* Pause Menu */
        #pause-menu { background: rgba(0,0,0,0.8); z-index: 100; }
        
        /* Swap Bubble Text Reposition */
        #swap-text {
            position: absolute; 
            bottom: 70px; 
            width: 100%; 
            text-align: center; 
            opacity: 0.7; 
            font-family: 'Roboto', sans-serif; 
            color: var(--accent); 
            font-size: 14px; 
            pointer-events: none; 
            text-shadow: 0 1px 2px black;
        }
    </style>
</head>
<body>

<div id="stage">
    <canvas id="gameCanvas" width="720" height="1280"></canvas>
    
    <div id="hud" class="ui-layer hidden">
        <div class="top-bar">
            <div class="score-box" style="text-align: left;">
                <div class="score-label">LEVEL</div>
                <div class="score-val" id="levelEl">1</div>
            </div>

            <div class="btn-icon interactive" id="pauseBtn" title="Pause">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
            </div>
        </div>

        <div id="swap-text">
            
        </div>
        
        <div class="bottom-bar">
            <div class="score-box">
                <div class="score-label">SCORE</div>
                <div class="score-val" id="scoreEl">0</div>
            </div>

            <div id="shots-indicator">
                <div class="score-label" style="margin-bottom:5px;" id="dropLabel">NEXT DROP</div>
                <div class="drop-counter" id="shotsUi">
                    <div class="drop-dot"></div><div class="drop-dot"></div>
                    <div class="drop-dot"></div><div class="drop-dot"></div>
                    <div class="drop-dot"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="pause-menu" class="ui-layer hidden interactive">
        <div class="card">
            <h1>PAUSED</h1>
            <button class="btn-main" id="resumeBtn">RESUME</button>
            <button class="btn-main" id="quitBtn" style="background: #333; border-color:#555;">QUIT TO MENU</button>
        </div>
    </div>

    <div id="main-menu" class="ui-layer interactive">
        <div class="card">
            <h1>NAINO<br>BUBBLE</h1>
            <div style="color:white; font-family:'Roboto'; margin-bottom:20px; letter-spacing:2px;">NEW CHALLENGE EVERYTIME</div>
            
            <button class="btn-main" id="btnLevels">PLAY LEVELS</button>
            
            <div class="btn-row">
                <div class="btn-icon" id="btnTheme" title="Change Theme">
                    <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
                        <path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c1.03 0 2-.19 2.92-.51l2.36 2.36 1.41-1.41-2.36-2.36c.32-.92.51-1.93.51-3.08 0-4.97-4.03-9-9-9zm4.5 4c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zM8.5 8c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm-4 4c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm8 4c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2z"/>
                    </svg>
                </div>
                <div class="btn-icon" id="btnSound" title="Toggle Sound">
                    <svg id="sndIcon" viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
                </div>
                <div class="btn-icon" id="btnInfo" title="Info">
                    <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>
                </div>
            </div>
        </div>
    </div>

    <div id="game-over" class="ui-layer hidden interactive">
        <div class="card">
            <h1 style="color: #ff4444; font-size: 40px;">GAME OVER</h1>
            <div class="score-label">FINAL SCORE</div>
            <div class="score-val" id="goScore">0</div>
            <br>
            <button class="btn-main" id="retryBtn">TRY AGAIN</button>
            <button class="btn-main" id="homeBtn" style="background: #333; border-color:#555;">MAIN MENU</button>
        </div>
    </div>
    
    <div id="info-modal" class="ui-layer hidden interactive" style="background:rgba(0,0,0,0.9);">
        <div class="card">
            <h2>CREDITS</h2>
            <p style="color:white; font-family:'Roboto';">Developed by Nawab Husnain</p>
            <br>
            <button class="btn-main" id="closeInfoBtn">CLOSE</button>
        </div>
    </div>
</div>

<script>
const THEMES = [
    { name: 'Carnival', bg: '#2E004F', pat: '#580096', acc: '#FFD700', accD: '#DAA520', colors: ['#ff4444', '#4488ff', '#44ff44', '#ffff44', '#ff44ff', '#ff8800'] },
    { name: 'Ocean',    bg: '#001e36', pat: '#003366', acc: '#00f2ff', accD: '#0099cc', colors: ['#00FFFF', '#00AAFF', '#00FF7F', '#A0FF00', '#FF00A0', '#FF8C00'] },
    { name: 'Neon',     bg: '#111111', pat: '#222222', acc: '#ff0055', accD: '#990033', colors: ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'] }
];

const C = {
    W: 720, H: 1280,
    RADIUS: 32,
    ROWS: 14, COLS: 11,
    ROOF_PLATE_HEIGHT: 40,
    ROOF_Y_BOTTOM: 40, 
    SHOOTER_DANGER_Y: 1050, // Game Over Line
    SHOOT_SPEED: 45, 
    MAX_SHOTS_BEFORE_COMPRESSOR: 5, 
    MAX_LEVELS: 40, 
};

// --- SYMMETRICAL LEVEL GENERATION FUNCTION ---
const generateSymmetricalLevelMap = (level, colorsCount) => {
    const numRows = Math.min(C.ROWS, 3 + Math.floor(level / 5)); 
    const map = [];
    const stoneChance = Math.min(0.2, (level - 1) * 0.01); 
    const bombChance = level >= 10 ? 0.05 : 0; // 5% chance for a bomb after level 10

    for (let r = 0; r < numRows; r++) {
        const isEvenRow = (r % 2 === 0);
        const rowLength = isEvenRow ? C.COLS : C.COLS - 1; 
        const leftHalfCount = isEvenRow ? 6 : 5; 
        let row = new Array(rowLength).fill(0); 
        
        for (let c = 0; c < leftHalfCount; c++) {
            let bubbleType = 0;
            
            if (Math.random() > 0.2) { // 80% chance for a bubble to be placed
                
                if (Math.random() < bombChance) {
                    bubbleType = 10; // Bomb (Type 10)
                } 
                else if (Math.random() < stoneChance) {
                    bubbleType = 9; // Stone (Type 9)
                } else {
                    bubbleType = (Math.floor(Math.random() * colorsCount) + 1); // Regular color (1 to 6)
                }
            }
            
            // Set the left bubble
            row[c] = bubbleType;
            
            // Mirror to the Right Half
            const mirrorC = (rowLength - 1) - c;
            if (mirrorC !== c) {
                row[mirrorC] = bubbleType;
            }
        }
        
        map.push(row);
    }
    return map;
};
// --- END SYMMETRICAL LEVEL GENERATION FUNCTION ---


const AudioEngine = {
    ctx: null, muted: false,
    init() { 
        if (!this.ctx) { 
            window.AudioContext = window.AudioContext || window.webkitAudioContext; 
            this.ctx = new AudioContext(); 
        }
    },
    play(t, f, d, v=0.1) {
        if(this.muted || !this.ctx) return;
        if(this.ctx.state === 'suspended') this.ctx.resume();
        const o=this.ctx.createOscillator(), g=this.ctx.createGain();
        o.type=t; o.frequency.setValueAtTime(f, this.ctx.currentTime);
        g.gain.setValueAtTime(v, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime+d);
        o.connect(g); g.connect(this.ctx.destination);
        o.start(); o.stop(this.ctx.currentTime+d);
    },
    shoot(){ this.play('triangle', 600, 0.1, 0.2); },
    pop(){ this.play('sine', 800+Math.random()*200, 0.1, 0.2); },
    thud(){ this.play('square', 100, 0.1, 0.1); },
    clang(){ this.play('sawtooth', 150, 0.4, 0.2); }
};

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y;
        this.vx = (Math.random()-0.5)*12;
        this.vy = (Math.random()-0.5)*12;
        this.life = 1.0;
        this.color = color;
    }
    update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, 5, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.state = 'MENU'; 
        this.themeIdx = 0;
        this.colors = THEMES[0].colors;
        
        this.grid = [];
        this.particles = [];
        this.falling = [];
        
        this.score = 0;
        this.level = 0;
        this.shotsSinceCompressor = 0; 
        
        this.roofY = 0;
        
        this.shooter = { 
            x: C.W/2, y: C.H-120, 
            angle: -Math.PI/2, 
            curr: 0, next: 0, 
            bubble: null,
            recoil: 0
        };
        
        this.input = { active: false, x: 0, y: 0 };
        this.time = 0;

        this.initGrid();
        this.bindEvents();
        this.setTheme(0);
        this.loop();
    }
    
    setTheme(idx) {
        this.themeIdx = idx % THEMES.length;
        const t = THEMES[this.themeIdx];
        this.colors = t.colors;
        const r = document.documentElement.style;
        r.setProperty('--bg-color', t.bg);
        r.setProperty('--bg-pattern', t.pat);
        r.setProperty('--accent', t.acc);
        r.setProperty('--accent-dark', t.accD);
        r.setProperty('--ui-glass', t.uiGlass || `rgba(${parseInt(t.bg.slice(1,3), 16)}, ${parseInt(t.bg.slice(3,5), 16)}, ${parseInt(t.bg.slice(5,7), 16)}, 0.95)`);
    }

    initGrid() {
        this.grid = [];
        for(let r=0; r<C.ROWS; r++) {
            this.grid[r] = [];
            for(let c=0; c<C.COLS; c++) this.grid[r][c] = null;
        }
    }

    startLevel(idx) {
        this.level = idx;
        if(idx >= C.MAX_LEVELS) {
            this.level = 1; 
        }
        
        this.resetGame();
        
        // Initial bottom edge of the roof plate
        this.roofY = C.ROOF_Y_BOTTOM; 
        
        const map = generateSymmetricalLevelMap(this.level, this.colors.length);
        
        for(let r=0; r<map.length; r++) {
            for(let c = 0; c < map[r].length; c++) {
                if(map[r][c] > 0) {
                    let type = 'normal';
                    let col = map[r][c] - 1; // 1-6 map to 0-5
                    
                    if(map[r][c] === 9) {
                        type = 'stone';
                        col = 9; // Stone uses index 9 (or a non-color index)
                    } else if (map[r][c] === 10) {
                        type = 'bomb';
                        col = 10; // Bomb uses index 10
                    }
                    this.grid[r][c] = { color: col, type: type, anim: 0 };
                }
            }
        }
    }

    resetGame() {
        this.state = 'PLAY';
        this.score = 0;
        this.shotsSinceCompressor = 0;
        this.falling = [];
        this.particles = [];
        this.initGrid();
        this.shooter.curr = Math.floor(Math.random()*this.colors.length);
        this.shooter.next = Math.floor(Math.random()*this.colors.length);
        this.updateHUD();
        this.hideModals();
        document.getElementById('hud').classList.remove('hidden');
        AudioEngine.init();
    }
    
    hideModals() {
        document.querySelectorAll('.ui-layer').forEach(el => {
            if(el.id !== 'hud') el.classList.add('hidden');
        });
    }

    update() {
        this.time++;
        if(this.shooter.recoil > 0) this.shooter.recoil *= 0.8;

        if(this.state !== 'PLAY') return;

        for(let i=this.particles.length-1; i>=0; i--) {
            this.particles[i].update();
            if(this.particles[i].life<=0) this.particles.splice(i,1);
        }

        for(let i=this.falling.length-1; i>=0; i--) {
            let b = this.falling[i];
            b.y += b.vy; b.vy += 0.5; b.x += b.vx;
            if(b.y > C.H) this.falling.splice(i,1);
        }

        if(this.shooter.bubble) {
            let b = this.shooter.bubble;
            b.x += b.vx; b.y += b.vy;
            
            // Wall Bounce
            if(b.x < C.RADIUS || b.x > C.W-C.RADIUS) {
                b.vx *= -1;
                b.x = b.x<C.RADIUS ? C.RADIUS : C.W-C.RADIUS;
            }

            let topCollisionY = this.roofY + C.RADIUS;
            
            if(b.y < topCollisionY || this.checkCollision(b)) {
                this.snapBubble();
            }
        }
    }

    checkCollision(b) {
        for(let r=0; r<C.ROWS; r++) {
            for(let c=0; c<C.COLS; c++) {
                if(this.grid[r][c]) {
                    let pos = this.getGridPos(r,c);
                    let dist = Math.hypot(b.x-pos.x, b.y-pos.y);
                    if(dist < C.RADIUS*1.8) return true;
                }
            }
        }
        return false;
    }

    // --- NEW: Handle Bomb Explosion ---
    explodeBubble(r, c) {
        if (r < 0 || r >= C.ROWS || c < 0 || c >= C.COLS || !this.grid[r][c] || this.grid[r][c].color !== 10) {
            return;
        }

        AudioEngine.pop(); 
        let pos = this.getGridPos(r, c);
        
        // Explosion particles
        for(let i=0; i<20; i++) this.particles.push(new Particle(pos.x, pos.y, '#FF0000'));
        
        // Collect all neighbors (including the bomb itself)
        const area = [{r,c}];
        this.getNeighbors(r, c).forEach(n => area.push(n));
        
        let bombExploded = false;
        
        area.forEach(({r: er, c: ec}) => {
            if (er >= 0 && er < C.ROWS && ec >= 0 && ec < C.COLS) {
                if (this.grid[er] && this.grid[er][ec]) {
                    
                    if(this.grid[er][ec].color === 10) bombExploded = true;
                    
                    // Pop anything in the blast radius (normal/stone/bomb)
                    let pPos = this.getGridPos(er, ec);
                    let pColor = '#FF0000'; // Default to bomb color
                    if (this.grid[er][ec].color !== 10) {
                        pColor = this.grid[er][ec].color === 9 ? '#888' : this.colors[this.grid[er][ec].color];
                        this.score += 100; // Popping a normal/stone bubble
                    } else {
                        this.score += 500; // Destroying a bomb
                    }

                    for(let i=0; i<5; i++) this.particles.push(new Particle(pPos.x, pPos.y, pColor));
                    this.grid[er][ec] = null;
                }
            }
        });
        return bombExploded; // Return true if a bomb was actually cleared
    }
    // --- END Bomb Logic ---

    snapBubble() {
        const b = this.shooter.bubble;
        this.shooter.bubble = null;
        AudioEngine.thud();

        let bestD = Infinity, br=-1, bc=-1;
        
        for(let r=0; r<C.ROWS; r++) {
            for(let c=0; c<C.COLS; c++) {
                if(!this.grid[r][c]) {
                    let pos = this.getGridPos(r,c);
                    let d = Math.hypot(b.x-pos.x, b.y-pos.y);
                    if(d < bestD && d < C.RADIUS*2.5) {
                        bestD = d; br=r; bc=c;
                    }
                }
            }
        }

        if(br !== -1) {
            // Place the bubble temporarily (it will be removed if it explodes or matches)
            this.grid[br][bc] = { color: b.color, type: 'normal', anim: 10 };
            const snappedR = br; 
            const snappedC = bc;
            
            const matches = this.findMatches(snappedR, snappedC, b.color);
            
            this.shotsSinceCompressor++;
            if (this.shotsSinceCompressor >= C.MAX_SHOTS_BEFORE_COMPRESSOR) {
                this.shotsSinceCompressor = 0;
                this.moveRoofDown();
            }

            let exploded = false;
            let bombsToExplode = new Set();
            
            // Collect positions to check for adjacent bombs: the snapped bubble + all matched bubbles
            const bombCheckPositions = [{r: snappedR, c: snappedC}]; 
            if (matches.length >= 3) {
                matches.forEach(m => bombCheckPositions.push(m));
            }

            // 1. Find all unique bombs adjacent to the newly snapped/matched bubbles
            bombCheckPositions.forEach(p => {
                this.getNeighbors(p.r, p.c).forEach(n => {
                    const cell = this.grid[n.r][n.c];
                    if (cell && cell.color === 10) {
                        bombsToExplode.add(`${n.r},${n.c}`);
                    }
                });
            });

            // 2. Explode the bombs
            bombsToExplode.forEach(coord => {
                const [r, c] = coord.split(',').map(Number);
                if (this.explodeBubble(r, c)) exploded = true;
            });
            
            // 3. Clear regular matches ONLY if no bomb explosion occurred at the contact point
            if(matches.length >= 3 && !exploded) {
                AudioEngine.pop();
                matches.forEach(m => {
                    let pos = this.getGridPos(m.r, m.c);
                    // Check if the match bubble wasn't already cleared by an earlier bomb explosion
                    if(this.grid[m.r][m.c]) { 
                        for(let i=0; i<5; i++) this.particles.push(new Particle(pos.x, pos.y, this.colors[this.grid[m.r][m.c].color]));
                        this.grid[m.r][m.c] = null;
                        this.score += 100;
                    }
                });
            }
            // Clear the original snapped bubble if it wasn't already cleared by explosion/match
            if(this.grid[snappedR][snappedC] && matches.length < 3 && !exploded) {
                // If it didn't match and didn't trigger a bomb, it stays.
            } else if (this.grid[snappedR][snappedC] && (matches.length >= 3 || exploded)) {
                // If it matched OR exploded, clear the snapped bubble itself
                this.grid[snappedR][snappedC] = null;
            }


            // 4. Drop orphans if anything was cleared
            if (matches.length >= 3 || exploded) {
                this.dropOrphans();
            }

            // **GAME OVER CHECK 1: If the position of the bubble snapped below the danger line**
            // The position check must still happen regardless of the final state of that cell.
            if (this.getGridPos(snappedR, snappedC).y > C.SHOOTER_DANGER_Y) {
                this.gameOver();
            } else if (this.isLevelClear()) {
                setTimeout(() => this.startLevel(this.level+1), 1000);
            }
            this.updateHUD();
        }
    }

    moveRoofDown() {
        this.roofY += C.RADIUS * 1.74; 
        AudioEngine.clang();
        
        // **GAME OVER CHECK 2: Check ALL existing bubbles against the danger line**
        for(let r=0; r<C.ROWS; r++) {
            for(let c=0; c<C.COLS; c++) {
                if(this.grid[r][c] && this.getGridPos(r,c).y > C.SHOOTER_DANGER_Y) {
                    this.gameOver();
                    return; 
                }
            }
        }
    }

    findMatches(r,c,col) {
        let match = [], q = [{r,c}], v = new Set([r+','+c]);
        while(q.length) {
            let cur = q.pop(); match.push(cur);
            this.getNeighbors(cur.r, cur.c).forEach(n => {
                let cell = this.grid[n.r][n.c];
                // Only match colored bubbles (not stone or bomb)
                if(cell && cell.color === col && cell.type === 'normal' && !v.has(n.r+','+n.c)) { 
                    v.add(n.r+','+n.c); q.push(n);
                }
            });
        }
        return match;
    }

    dropOrphans() {
        let v = new Set(), q = [];
        for(let c=0; c<C.COLS; c++) {
            if(this.grid[0][c]) { 
                q.push({r:0,c}); 
                v.add('0,'+c); 
            }
        }
        
        while(q.length) {
            let cur = q.shift();
            this.getNeighbors(cur.r, cur.c).forEach(n => {
                if(this.grid[n.r][n.c] && !v.has(n.r+','+n.c)) { 
                    v.add(n.r+','+n.c); q.push(n); 
                }
            });
        }
        
        for(let r=0; r<C.ROWS; r++) {
            for(let c=0; c<C.COLS; c++) {
                if(this.grid[r][c] && !v.has(r+','+c)) {
                    let pos = this.getGridPos(r,c);
                    this.falling.push({ x:pos.x, y:pos.y, vx:(Math.random()-0.5)*5, vy:-5, color:this.grid[r][c].color });
                    this.grid[r][c] = null; 
                    this.score += 50;
                }
            }
        }
    }
    
    getNeighbors(r,c) {
        const odd = (r%2!==0);
        const dirs = odd 
            ? [[0,-1],[0,1],[-1,0],[-1,1],[1,0],[1,1]] 
            : [[0,-1],[0,1],[-1,-1],[-1,0],[1,-1],[1,0]];
        
        let res=[];
        dirs.forEach(d=>{
            let nr=r+d[0], nc=c+d[1];
            if(nr>=0 && nr<C.ROWS && nc>=0 && nc<C.COLS) res.push({r:nr,c:nc});
        });
        return res;
    }

    getGridPos(r,c) {
        const offY_R0_center = this.roofY + C.RADIUS; 
        const offX = (r%2===0) ? 0 : C.RADIUS;
        return { 
            x: (c*C.RADIUS*2)+C.RADIUS+offX+8, 
            y: offY_R0_center + (r*C.RADIUS*1.74) 
        };
    }

    isLevelClear() {
        for(let r=0; r<C.ROWS; r++) for(let c=0; c<C.COLS; c++) if(this.grid[r][c]) return false;
        return true;
    }

    gameOver() {
        this.state = 'GAMEOVER';
        this.shooter.bubble = null;
        document.getElementById('hud').classList.add('hidden');
        document.getElementById('game-over').classList.remove('hidden');
        document.getElementById('goScore').innerText = this.score;
    }

    updateHUD() {
        document.getElementById('scoreEl').innerText = this.score;
        document.getElementById('levelEl').innerText = this.level;
        const dots = document.querySelectorAll('#shotsUi .drop-dot');
        dots.forEach((d,i) => d.classList.toggle('active', i < this.shotsSinceCompressor));
    }

    // --- RENDERING ---
    drawBubble(x, y, r, colorIdx, type='normal', scale=1) {
        const ctx = this.ctx;
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);

        // Stone Bubble (Type 9)
        if(type === 'stone' || colorIdx === 9) {
            ctx.fillStyle = '#444'; ctx.beginPath(); ctx.arc(0,0,r-2,0,Math.PI*2); ctx.fill();
            ctx.strokeStyle='#888'; ctx.lineWidth=3; ctx.stroke();
            ctx.restore(); return;
        }

        // Bomb Bubble (Type 10)
        if (colorIdx === 10 || type === 'bomb') {
            ctx.fillStyle = '#C00'; ctx.beginPath(); ctx.arc(0,0,r-2,0,Math.PI*2); ctx.fill();
            ctx.strokeStyle='#333'; ctx.lineWidth=3; ctx.stroke();
            ctx.fillStyle = '#000'; ctx.font = `bold ${r}px Rye`; ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillText('B', 0, 5); 
            ctx.restore(); return;
        }

        // Normal Bubble (Type 0-5)
        const color = this.colors[colorIdx];
        
        ctx.shadowBlur = 10;
        ctx.shadowColor = color;
        
        let grad = ctx.createRadialGradient(r*0.3, r*0.3, 0, 0, 0, r);
        grad.addColorStop(0, 'white');
        grad.addColorStop(0.3, color);
        grad.addColorStop(1, color);
        ctx.fillStyle = grad;
        ctx.beginPath(); 
        ctx.arc(0, 0, r - 1, 0, Math.PI * 2); 
        ctx.fill();
        
        ctx.shadowBlur = 0; 

        ctx.beginPath();
        ctx.ellipse(-r*0.4, -r*0.4, r*0.4, r*0.2, Math.PI/4 + 0.5, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; ctx.fill();
        ctx.beginPath();
        ctx.arc(r*0.3, -r*0.3, r*0.1, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.fill();

        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0,0,r-1,0,Math.PI*2); ctx.stroke();

        ctx.restore();
    }

    drawShooter() {
        const ctx = this.ctx;
        const s = this.shooter;
        
        // Draw Aim Line
        if(this.state === 'PLAY' && !s.bubble && this.input.active) {
            ctx.beginPath();
            let tx = s.x, ty = s.y;
            let ang = s.angle;
            let dx = Math.cos(ang)*20, dy = Math.sin(ang)*20;
            
            ctx.moveTo(tx, ty);
            for(let i=0; i<30; i++) {
                tx += dx; ty += dy;
                if(tx < C.RADIUS || tx > C.W-C.RADIUS) { dx *= -1; tx += dx; }
                ctx.lineTo(tx, ty);
            }
            
            ctx.strokeStyle = "rgba(255,255,255,0.4)";
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 15]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        ctx.save();
        ctx.translate(s.x, s.y);

        // Shooter Turret
        ctx.fillStyle = '#1A1A1A';
        ctx.beginPath();
        ctx.ellipse(0, 30, 80, 25, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#555'; ctx.lineWidth = 5; ctx.stroke();
        
        ctx.fillStyle = '#444';
        ctx.beginPath();
        ctx.arc(0, 0, 35, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 2;
        for(let i=0; i<8; i++) {
            ctx.beginPath();
            ctx.arc(0, 0, 32, (i * Math.PI/4) - 0.1, (i * Math.PI/4) + 0.1);
            ctx.stroke();
        }

        // Rotating Barrel Assembly
        ctx.rotate(s.angle + Math.PI/2);
        ctx.translate(0, s.recoil);
        
        ctx.fillStyle = '#777';
        ctx.fillRect(-15, -65, 30, 70);
        
        let goldGrad = ctx.createLinearGradient(-35, -70, 35, -70);
        goldGrad.addColorStop(0, '#FFF5BA'); 
        goldGrad.addColorStop(0.4, '#FFD700'); 
        goldGrad.addColorStop(1, '#A08000');
        ctx.fillStyle = goldGrad;

        ctx.beginPath();
        ctx.moveTo(-35, -5);
        ctx.lineTo(-25, -70);
        ctx.lineTo(25, -70);
        ctx.lineTo(35, -5);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#111';
        ctx.fillRect(-27, -80, 54, 10);
        
        ctx.restore();

        // Bubbles
        if(s.bubble) {
            this.drawBubble(s.bubble.x, s.bubble.y, C.RADIUS, s.bubble.color);
        } else {
            this.drawBubble(s.x, s.y, C.RADIUS*0.8, s.curr); // Loaded
        }
        this.drawBubble(s.x-100, s.y+20, C.RADIUS*0.6, s.next); // Next
    }

    drawRoof() {
        const ctx = this.ctx;
        const y = this.roofY; 
        const plateHeight = C.ROOF_PLATE_HEIGHT; 
        const topY = y - plateHeight; 
        
        let goldGrad = ctx.createLinearGradient(0, topY, 0, y);
        goldGrad.addColorStop(0, '#C0A040'); 
        goldGrad.addColorStop(0.5, '#FFD700'); 
        goldGrad.addColorStop(1, '#C0A040');
        ctx.fillStyle = goldGrad;
        ctx.fillRect(0, topY, C.W, plateHeight);
        
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 2;
        for(let i=0; i<C.W; i+=50) {
            ctx.beginPath();
            ctx.moveTo(i, topY + 5);
            ctx.lineTo(i + 25, y - plateHeight/2);
            ctx.lineTo(i + 50, topY + 5);
            ctx.stroke();
        }
        
        const pistonWidth = 30;
        const pistonX1 = 100;
        const pistonX2 = C.W - 100 - pistonWidth;
        
        ctx.fillStyle = '#444';
        ctx.fillRect(pistonX1, 0, pistonWidth, topY);
        ctx.fillRect(pistonX2, 0, pistonWidth, topY);

        ctx.fillStyle = '#AAA';
        ctx.fillRect(pistonX1 + 10, y - 30, 10, 30);
        ctx.fillRect(pistonX2 + 10, y - 30, 10, 30);

        ctx.fillStyle = '#8B6914';
        ctx.fillRect(0, y, C.W, 5);
    }

    loop() {
        requestAnimationFrame(() => this.loop());
        
        this.ctx.clearRect(0,0,C.W,C.H);

        this.drawRoof();

        for(let r=0; r<C.ROWS; r++) {
            for(let c=0; c<C.COLS; c++) {
                if(this.grid[r][c]) {
                    const pos = this.getGridPos(r,c);
                    let scale = 1;
                    if(this.grid[r][c].anim > 0) {
                        scale = 1 + Math.sin(this.grid[r][c].anim)*0.1;
                        this.grid[r][c].anim--;
                    }
                    this.drawBubble(pos.x, pos.y, C.RADIUS, this.grid[r][c].color, this.grid[r][c].type, scale);
                }
            }
        }
        
        this.falling.forEach(b => this.drawBubble(b.x, b.y, C.RADIUS, b.color));
        this.particles.forEach(p => p.draw(this.ctx));
        
        this.drawShooter();
        
        // Danger Line (Red Dotted Line)
        if(this.state === 'PLAY') {
            this.ctx.beginPath();
            this.ctx.moveTo(0, C.SHOOTER_DANGER_Y);
            this.ctx.lineTo(C.W, C.SHOOTER_DANGER_Y);
            this.ctx.strokeStyle = "rgba(255,0,0,0.8)";
            this.ctx.lineWidth = 5; // Increased width for visibility
            this.ctx.setLineDash([15,10]);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }

        if(this.state === 'PLAY') this.update();
    }
    
    // --- INPUT & UI ---
    togglePause() {
        if(this.state === 'PLAY') {
            this.state = 'PAUSED';
            document.getElementById('pause-menu').classList.remove('hidden');
        } else if(this.state === 'PAUSED') {
            this.state = 'PLAY';
            document.getElementById('pause-menu').classList.add('hidden');
        }
    }

    bindEvents() {
        const move = (x,y) => {
            this.input.x = x; this.input.y = y;
            let dx = x - this.shooter.x, dy = y - this.shooter.y;
            let ang = Math.atan2(dy, dx);
            if(ang > -0.2) ang = -0.2; if(ang < -2.94) ang = -2.94;
            this.shooter.angle = ang;
        };

        const tapStart = (x,y) => {
            if(this.state !== 'PLAY' && this.state !== 'MENU') return;
            // Swap area check (near shooter)
            if(y > C.H - 150 && Math.abs(x - this.shooter.x) < C.RADIUS*2) {
                let t = this.shooter.curr; this.shooter.curr = this.shooter.next; this.shooter.next = t;
            } else if (this.state === 'PLAY') {
                this.input.active = true;
                move(x,y);
            }
        };

        const tapEnd = () => {
            if(this.input.active && this.state === 'PLAY') {
                this.input.active = false;
                if(!this.shooter.bubble) {
                    AudioEngine.shoot();
                    this.shooter.recoil = 15;
                    this.shooter.bubble = {
                        x: this.shooter.x, y: this.shooter.y,
                        vx: Math.cos(this.shooter.angle)*C.SHOOT_SPEED,
                        vy: Math.sin(this.shooter.angle)*C.SHOOT_SPEED,
                        color: this.shooter.curr
                    };
                    this.shooter.curr = this.shooter.next;
                    this.shooter.next = Math.floor(Math.random()*this.colors.length);
                }
            }
        };

        const canvasToGameCoords = (clientX, clientY) => {
            const r = this.canvas.getBoundingClientRect();
            return {
                x: (clientX - r.left) * (C.W / r.width),
                y: (clientY - r.top) * (C.H / r.height)
            };
        };

        this.canvas.addEventListener('mousedown', e => {
            const {x, y} = canvasToGameCoords(e.clientX, e.clientY);
            tapStart(x, y);
        });
        this.canvas.addEventListener('mousemove', e => {
            if(this.input.active) {
                const {x, y} = canvasToGameCoords(e.clientX, e.clientY);
                move(x, y);
            }
        });
        window.addEventListener('mouseup', tapEnd);
        
        this.canvas.addEventListener('touchstart', e => { e.preventDefault();
            const {x, y} = canvasToGameCoords(e.touches[0].clientX, e.touches[0].clientY);
            tapStart(x, y);
        }, {passive:false});
        this.canvas.addEventListener('touchmove', e => { e.preventDefault();
            if(this.input.active) {
                const {x, y} = canvasToGameCoords(e.touches[0].clientX, e.touches[0].clientY);
                move(x, y);
            }
        }, {passive:false});
        window.addEventListener('touchend', tapEnd);
        
        // UI Handlers
        document.getElementById('pauseBtn').onclick = () => this.togglePause();
        document.getElementById('resumeBtn').onclick = () => this.togglePause();
        document.getElementById('quitBtn').onclick = () => {
            this.state = 'MENU';
            this.hideModals();
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
        };
        
        document.getElementById('btnLevels').onclick = () => this.startLevel(1); 
        document.getElementById('retryBtn').onclick = () => this.startLevel(this.level);
        document.getElementById('homeBtn').onclick = () => document.getElementById('quitBtn').click();
        
        document.getElementById('btnTheme').onclick = () => this.setTheme(this.themeIdx + 1);
        
        document.getElementById('btnSound').onclick = () => { 
            AudioEngine.muted = !AudioEngine.muted; 
            document.getElementById('sndIcon').style.opacity = AudioEngine.muted?0.5:1; 
        };
        
        document.getElementById('btnInfo').onclick = () => document.getElementById('info-modal').classList.remove('hidden');
        document.getElementById('closeInfoBtn').onclick = () => document.getElementById('info-modal').classList.add('hidden');
    }
}

window.onload = () => new Game();
</script>
</body>
</html>